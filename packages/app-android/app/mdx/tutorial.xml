<?xml version="1.0" encoding="UTF-8"?>
    <StackLayout xmlns="http://schemas.nativescript.org/tns.xsd" text-wrap="true"><HtmlView selectable="true" html="&lt;h1&gt;$tutorial &lt;sub&gt;by &lt;a href=&quot;https://www.skilldrick.co.uk/&quot;&gt;nick morgan&lt;/a&gt;, licensed under cc by 4.0&lt;/sub&gt;&lt;/h1&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;h2&gt;$introduction&lt;/h2&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$in this tiny tutorial i&amp;apos;m going to show you how to get started writing 6502 assembly language. the 6502 processor was massive in the seventies and eighties, powering famous computers like the &lt;a href=&quot;http://en.wikipedia.org/wiki/bbc_micro&quot;&gt;bbc micro&lt;/a&gt;, &lt;a href=&quot;http://en.wikipedia.org/wiki/atari_2600&quot;&gt;atari 2600&lt;/a&gt;, &lt;a href=&quot;http://en.wikipedia.org/wiki/commodore_64&quot;&gt;commodore 64&lt;/a&gt;, &lt;a href=&quot;http://en.wikipedia.org/wiki/apple_ii&quot;&gt;apple ii&lt;/a&gt;, and the &lt;a href=&quot;http://en.wikipedia.org/wiki/nintendo_entertainment_system&quot;&gt;nintendo entertainment system&lt;/a&gt;. bender in futurama &lt;a href=&quot;http://www.transbyte.org/sid/sid-files/bender_6502.jpg&quot;&gt;has a 6502 processor for a brain&lt;/a&gt;. &lt;a href=&quot;http://www.pagetable.com/docs/terminator/00-37-23.jpg&quot;&gt;even the terminator was programmed in 6502&lt;/a&gt;.&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$so, why would you want to learn 6502? it&amp;apos;s a dead language isn&amp;apos;t it? well, so&amp;apos;s latin. and they still teach that. &lt;a href=&quot;http://en.wikipedia.org/wiki/q.e.d.&quot;&gt;q.e.d.&lt;/a&gt;&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$(actually, i&amp;apos;ve been reliably informed that 6502 processors are still being produced by &lt;a href=&quot;http://www.westerndesigncenter.com/wdc/w65c02s-chip.cfm&quot;&gt;western design center&lt;/a&gt; and &lt;a href=&quot;http://www.mouser.co.uk/search/refine.aspx?keyword=65c02&quot;&gt;sold to hobbyists&lt;/a&gt;, so clearly 6502 &lt;em&gt;isn&amp;apos;t&lt;/em&gt; a dead language! who knew?)&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$seriously though, i think it&amp;apos;s valuable to have an understanding of assembly language. assembly language is the lowest level of abstraction in computers - the point at which the code is still readable. assembly language translates directly to the bytes that are executed by your computer&amp;apos;s processor. if you understand how it works, you&amp;apos;ve basically become a computer &lt;a href=&quot;http://skilldrick.co.uk/2011/04/magic-in-software-development/&quot;&gt;magician&lt;/a&gt;.&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$then why 6502? why not a &lt;em&gt;useful&lt;/em&gt; assembly language, like &lt;a href=&quot;http://en.wikipedia.org/wiki/x86&quot;&gt;x86&lt;/a&gt;? well, i don&amp;apos;t think learning x86 is useful. i don&amp;apos;t think you&amp;apos;ll ever have to &lt;em&gt;write&lt;/em&gt; assembly language in your day job - this is purely an academic exercise, something to expand your mind and your thinking. 6502 was originally written in a different age, a time when the majority of developers were writing assembly directly, rather than in these new-fangled high-level programming languages. so, it was designed to be written by humans. more modern assembly languages are meant to written by compilers, so let&amp;apos;s leave it to them. plus, 6502 is &lt;em&gt;fun&lt;/em&gt;. nobody ever called x86 &lt;em&gt;fun&lt;/em&gt;.&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;h2&gt;$our first program&lt;/h2&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$so, let&amp;apos;s dive in! this application contains a &lt;a href=&quot;https://github.com/skilldrick/6502js&quot;&gt;java-script 6502 assembler and simulator&lt;/a&gt; that i have adapted for this interactive tutorial. click the &lt;strong&gt;copy&lt;/strong&gt; button in the code block below to copy the example code to the editor. then click the button in the top right to assemble the code, then click it again to run the program. you can also access these actions through the dropdown menu.&lt;/p&gt;"></HtmlView>

<HtmlView selectable="true" html="&lt;p&gt;$the black game console screen now should show three coloured &amp;quot;pixels&amp;quot; at the top left.&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$so, what&amp;apos;s this program actually doing? let&amp;apos;s step through it. hit &lt;strong&gt;reset&lt;/strong&gt;, then select &lt;strong&gt;step&lt;/strong&gt; from the dropdown menu. the button will switch to step mode, allowing you to execute the program one instruction at a time. click once and you&amp;apos;ll notice in the debugger that changed from to , and changed from to .&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$any numbers prefixed with in 6502 assembly language (and by extension, in this book) are in hexadecimal (hex) format. if you&amp;apos;re not familiar with hex numbers, i recommend you read &lt;a href=&quot;http://en.wikipedia.org/wiki/hexadecimal&quot;&gt;the wikipedia article&lt;/a&gt;. anything prefixed with is a literal number value. any other number refers to a memory location.&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$equipped with that knowledge, you should be able to see that the instruction loads the hex value into register . i&amp;apos;ll go into more detail on registers in the next section.&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$press &lt;strong&gt;step&lt;/strong&gt; again to execute the second instruction. the top-left pixel of the game console should now be white. this simulator uses the memory locations to to draw pixels on its display. the values to represent 16 different colours ( is black and is white), so storing the value at memory location draws a white pixel at the top left corner. this is simpler than how an actual computer would output video, but it&amp;apos;ll do for now.&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$so, the instruction stores the value of the register to memory location . click &lt;strong&gt;step&lt;/strong&gt; four more times to execute the rest of the instructions, keeping an eye on the register as it changes.&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;h3&gt;$exercises&lt;/h3&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;ol&gt;$ &lt;li&gt;try changing the colour of the three pixels.&lt;/li&gt; &lt;li&gt;change one of the pixels to draw at the bottom-right corner (memory location ).&lt;/li&gt; &lt;li&gt;add more instructions to draw extra pixels.&lt;/li&gt; &lt;/ol&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;h2&gt;$registers and flags&lt;/h2&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$we&amp;apos;ve already had a little look at the processor status section (the bit with , etc.), but what does it all mean?&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$the first line shows the , and registers ( is often called the &amp;quot;accumulator&amp;quot;). each register holds a single byte. most operations work on the contents of these registers.&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$ is the stack pointer. i won&amp;apos;t get into the stack yet, but basically this register is decremented every time a byte is pushed onto the stack, and incremented when a byte is popped off the stack.&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$ is the program counter - it&amp;apos;s how the processor knows at what point in the program it currently is. it&amp;apos;s like the current line number of an executing script. in the java-script simulator the code is assembled starting at memory location , so always starts there.&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$the last section shows the processor flags. each flag is one bit, so all seven flags live in a single byte. the flags are set by the processor to give information about the previous instruction. more on that later. &lt;a href=&quot;https://web.archive.org/web/20210626024532/http://www.obelisk.me.uk/6502/registers.html&quot;&gt;read more about the registers and flags here&lt;/a&gt;.&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;h2&gt;$instructions&lt;/h2&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$instructions in assembly language are like a small set of predefined functions. all instructions take zero or one arguments. here&amp;apos;s some annotated source code to introduce a few different instructions:&lt;/p&gt;"></HtmlView>

<HtmlView selectable="true" html="&lt;p&gt;$assemble the code, then turn on the debugger and step through the code, watching the and registers. something slightly odd happens on the line . you might expect that adding to would give , but this processor gives the result as . what&amp;apos;s up with that?&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$the problem is, is too big to fit in a single byte (the max is ), and the registers can only hold a single byte. it&amp;apos;s ok though; the processor isn&amp;apos;t actually dumb. if you were looking carefully enough, you&amp;apos;ll have noticed that the carry flag was set to after this operation. so that&amp;apos;s how you know.&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$in the simulator below &lt;strong&gt;type&lt;/strong&gt; (don&amp;apos;t paste) the following code:&lt;/p&gt;"></HtmlView>

<HtmlView selectable="true" html="&lt;p&gt;$an important thing to notice here is the distinction between and . the first one adds the value to the register, but the second adds the value stored at memory location to the register.&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$assemble the code and select &lt;strong&gt;step&lt;/strong&gt; from the run button&amp;apos;s dropdown menu to step through these three instructions. the monitor in the debugger shows a section of memory, and can be helpful to visualise the execution of programs. stores the value of the register at memory location , and adds the value stored at the memory location to the register. should equal , but because this is bigger than a byte, the register is set to and the carry flag is set. as well as this though, the zero flag is set. the zero flag is set by all instructions where the result is zero.&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$a full list of the 6502 instruction set is &lt;a href=&quot;http://www.6502.org/tutorials/6502opcodes.html&quot;&gt;available here&lt;/a&gt; and &lt;a href=&quot;http://www.obelisk.me.uk/6502/reference.html&quot;&gt;here&lt;/a&gt; (i usually refer to both pages as they have their strengths and weaknesses). these pages detail the arguments to each instruction, which registers they use, and which flags they set. they are your bible.&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;h3&gt;$exercises&lt;/h3&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;ol&gt;$ &lt;li&gt;you&amp;apos;ve seen . you can probably guess what , and do, but write some code to test your assumptions.&lt;/li&gt; &lt;li&gt;rewrite the first example in this section to use the register instead of the register.&lt;/li&gt; &lt;li&gt;the opposite of is (subtract with carry). write a program that uses this instruction.&lt;/li&gt; &lt;/ol&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;h2&gt;$branching&lt;/h2&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$so far we&amp;apos;re only able to write basic programs without any branching logic. let&amp;apos;s change that.&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$6502 assembly language has a bunch of branching instructions, all of which branch based on whether certain flags are set or not. in this example we&amp;apos;ll be looking at : &amp;quot;branch on not equal&amp;quot;.&lt;/p&gt;"></HtmlView>

<HtmlView selectable="true" html="&lt;p&gt;$first we load the value into the register. the next line is a label. labels just mark certain points in a program so we can return to them later. after the label we decrement , store it to (the top-left pixel), and then compare it to the value . &lt;a href=&quot;http://www.obelisk.me.uk/6502/reference.html#cpx&quot;&gt;&lt;/a&gt; compares the value in the register with another value. if the two values are equal, the flag is set to , otherwise it is set to .&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$the next line, , will shift execution to the decrement label if the flag is set to (meaning that the two values in the comparison were not equal), otherwise it does nothing and we store to , then finish the program.&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$in assembly language, you&amp;apos;ll usually use labels with branch instructions. when assembled though, this label is converted to a single-byte relative offset (a number of bytes to go backwards or forwards from the next instruction) so branch instructions can only go forward and back around 256 bytes. this means they can only be used to move around local code. for moving further you&amp;apos;ll need to use the jumping instructions.&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;h3&gt;$exercises&lt;/h3&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;ol&gt;$ &lt;li&gt;the opposite of is . try writing a program that uses .&lt;/li&gt; &lt;li&gt; and (&amp;quot;branch on carry clear&amp;quot; and &amp;quot;branch on carry set&amp;quot;) are used to branch on the carry flag. write a program that uses one of these two.&lt;/li&gt; &lt;/ol&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;h2&gt;$addressing modes&lt;/h2&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$the 6502 uses a 16-bit address bus, meaning that there are 65536 bytes of memory available to the processor. remember that a byte is represented by two hex characters, so the memory locations are generally represented as . there are various ways to refer to these memory locations, as detailed below.&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$with all these examples you might find it helpful to use the memory monitor in the debugger to watch the memory change. the monitor takes a starting memory location and a number of bytes to display from that location. both of these are hex values. for example, to display 16 bytes of memory from , enter and into &lt;strong&gt;start&lt;/strong&gt; and &lt;strong&gt;length&lt;/strong&gt;, respectively.&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;h3&gt;$absolute: &lt;/h3&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$with absolute addressing, the full memory location is used as the argument to the instruction. for example:&lt;/p&gt;"></HtmlView>

<HtmlView selectable="true" html="&lt;h3&gt;$zero page: &lt;/h3&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$all instructions that support absolute addressing (with the exception of the jump instructions) also have the option to take a single-byte address. this type of addressing is called &amp;quot;zero page&amp;quot; - only the first page (the first 256 bytes) of memory is accessible. this is faster, as only one byte needs to be looked up, and takes up less space in the assembled code as well.&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;h3&gt;$zero page,x: &lt;/h3&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$this is where addressing gets interesting. in this mode, a zero page address is given, and then the value of the register is added. here is an example:&lt;/p&gt;"></HtmlView>

<HtmlView selectable="true" html="&lt;p&gt;$if the result of the addition is larger than a single byte, the address wraps around. for example:&lt;/p&gt;"></HtmlView>

<HtmlView selectable="true" html="&lt;h3&gt;$zero page,y: &lt;/h3&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$this is the equivalent of zero page,x, but can only be used with and .&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;h3&gt;$absolute,x and absolute,y: and &lt;/h3&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$these are the absolute addressing versions of zero page,x and zero page,y. for example:&lt;/p&gt;"></HtmlView>

<HtmlView selectable="true" html="&lt;p&gt;$unlike zero page,y, absolute,y can&amp;apos;t be used with but can be used with and .&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;h3&gt;$immediate: &lt;/h3&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$immediate addressing doesn&amp;apos;t strictly deal with memory addresses - this is the mode where actual values are used. for example, loads the value into the register. this is very different to the zero page instruction which loads the value at memory location into the register.&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;h3&gt;$relative: (or label)&lt;/h3&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$relative addressing is used for branching instructions. these instructions take a single byte, which is used as an offset from the following instruction.&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$assemble the following code, then check the debugger to see the hexdump of the assembled code.&lt;/p&gt;"></HtmlView>

<HtmlView selectable="true" html="&lt;p&gt;$the hex should look something like this:&lt;/p&gt;"></HtmlView>

<HtmlView selectable="true" html="&lt;p&gt;$ and are the processor opcodes for immediate-addressed and respectively. and are the arguments to these instructions. is the opcode for , and its argument is . this means &amp;quot;skip over the next two bytes&amp;quot; (, the assembled version of ). try editing the code so takes a two-byte absolute address rather than a single-byte zero page address (e.g. change to ). reassemble the code and look at the hexdump again - the argument to should now be , because the instruction the processor is skipping past is now three bytes long.&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;h3&gt;$implicit&lt;/h3&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$some instructions don&amp;apos;t deal with memory locations (e.g. - increment the register). these are said to have implicit addressing - the argument is implied by the instruction.&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;h3&gt;$indirect: &lt;/h3&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$indirect addressing uses an absolute address to look up another address. the first address gives the least significant byte of the address, and the following byte gives the most significant byte. that can be hard to wrap your head around, so here&amp;apos;s an example:&lt;/p&gt;"></HtmlView>

<HtmlView selectable="true" html="&lt;p&gt;$in this example, contains the value and contains the value . the instruction causes the processor to look up the two bytes at and ( and ) and put them together to form the address , which becomes the new program counter. assemble and step through the program above to see what happens. i&amp;apos;ll talk more about in the section on &lt;a href=&quot;#jumping&quot;&gt;jumping&lt;/a&gt;.&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;h3&gt;$indexed indirect: &lt;/h3&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$this one&amp;apos;s kinda weird. it&amp;apos;s like a cross between zero page,x and indirect. basically, you take the zero page address, add the value of the register to it, then use that to look up a two-byte address. for example:&lt;/p&gt;"></HtmlView>

<HtmlView selectable="true" html="&lt;p&gt;$memory locations and contain the values and respectively. think of as . in this case is , so this simplifies to . from here things proceed like standard indirect addressing - the two bytes at and ( and ) are looked up to form the address . this is the address that the register was stored into in the previous instruction, so the register gets the same value as , albeit through a much more circuitous route. you won&amp;apos;t see this much.&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;h3&gt;$indirect indexed: &lt;/h3&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$indirect indexed is like indexed indirect but less insane. instead of adding the register to the address &lt;em&gt;before&lt;/em&gt; dereferencing, the zero page address is dereferenced, and the register is added to the resulting address.&lt;/p&gt;"></HtmlView>

<HtmlView selectable="true" html="&lt;p&gt;$in this case, looks up the two bytes at and : and . these form the address . the value of the register is added to this address to give the final address .&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;h3&gt;$exercise&lt;/h3&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;ol&gt;$ &lt;li&gt;try to write code snippets that use each of the 6502 addressing modes. remember, you can use the monitor in the debugger to watch a section of memory.&lt;/li&gt; &lt;/ol&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;h2&gt;$the stack&lt;/h2&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$the stack in a 6502 processor is just like any other stack - values are pushed onto it and popped (&amp;quot;pulled&amp;quot; in 6502 parlance) off it. the current depth of the stack is measured by the stack pointer, a special register. the stack lives in memory between and . the stack pointer is initially , which points to memory location . when a byte is pushed onto the stack, the stack pointer becomes , or memory location , and so on.&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$two of the stack instructions are and , &amp;quot;push accumulator&amp;quot; and &amp;quot;pull accumulator&amp;quot;. below is an example of these two in action.&lt;/p&gt;"></HtmlView>

<HtmlView selectable="true" html="&lt;p&gt;$ holds the pixel colour, and holds the position of the current pixel. the first loop draws the current colour as a pixel (via the register), pushes the colour to the stack, then increments the colour and position. the second loop pops the stack, draws the popped colour as a pixel, then increments the position. as should be expected, this creates a mirrored pattern.&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;h2&gt;$jumping&lt;/h2&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$jumping is like branching with two main differences. first, jumps are not conditionally executed, and second, they take a two-byte absolute address. for small programs, this second detail isn&amp;apos;t very important, as you&amp;apos;ll mostly be using labels, and the assembler works out the correct memory location from the label. for larger programs though, jumping is the only way to move from one section of the code to another.&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;h3&gt;$jmp&lt;/h3&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$ is an unconditional jump. here&amp;apos;s a really simple example to show it in action:&lt;/p&gt;"></HtmlView>

<HtmlView selectable="true" html="&lt;h3&gt;$jsr/rts&lt;/h3&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$ and (&amp;quot;jump to subroutine&amp;quot; and &amp;quot;return from subroutine&amp;quot;) are a dynamic duo that you&amp;apos;ll usually see used together. is used to jump from the current location to another part of the code. returns to the previous position. this is basically like calling a function and returning.&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$the processor knows where to return to because pushes the address minus one of the next instruction onto the stack before jumping to the given location. pops this location, adds one to it, and jumps to that location. an example:&lt;/p&gt;"></HtmlView>

<HtmlView selectable="true" html="&lt;p&gt;$the first instruction causes execution to jump to the label. this sets , then returns to the next instruction, . this jumps to the label, which increments until it is equal to . after that we return to the next instruction, , which jumps to the end of the file. this illustrates how and can be used together to create modular code.&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;h2&gt;$creating a game&lt;/h2&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$now, let&amp;apos;s put all this knowledge to good use, and make a game! we&amp;apos;re going to be making a really simple version of the classic game &amp;apos;snake&amp;apos;.&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$even though this will be a simple version, the code will be substantially larger than all the previous examples. we will need to keep track of several memory locations together for the various aspects of the game. we can still do the necessary bookkeeping throughout the program ourselves, as before, but on a larger scale that quickly becomes tedious and can also lead to bugs that are difficult to spot. instead we&amp;apos;ll now let the assembler do some of the mundane work for us.&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$in this assembler, we can define descriptive constants (or symbols) that represent numbers. the rest of the code can then simply use the constants instead of the literal number, which immediately makes it obvious what we&amp;apos;re dealing with. you can use letters, digits and underscores in a name.&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$here&amp;apos;s an example. note that immediate operands are still prefixed with a .&lt;/p&gt;"></HtmlView>

<HtmlView selectable="true" html="&lt;p&gt;$the code block below contains the entire source code of the game. i&amp;apos;ll explain how it works in the following sections.&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$&lt;a href=&quot;https://twitter.com/wkjagt&quot;&gt;willem van der jagt&lt;/a&gt; made a &lt;a href=&quot;https://gist.github.com/wkjagt/9043907&quot;&gt;fully annotated gist of this source code&lt;/a&gt;, so follow along with that for more details.&lt;/p&gt;"></HtmlView>

<HtmlView selectable="true" html="&lt;h3&gt;$overall structure&lt;/h3&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$after the initial block of comments (lines starting with semicolons), the first two lines are:&lt;/p&gt;"></HtmlView>

<HtmlView selectable="true" html="&lt;p&gt;$ and are both subroutines. initializes the game state, and is the main game loop.&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$the subroutine itself just calls a number of subroutines sequentially, before looping back on itself:&lt;/p&gt;"></HtmlView>

<HtmlView selectable="true" html="&lt;p&gt;$first, checks to see if one of the direction keys (w, a, s, d) was pressed, and if so, sets the direction of the snake accordingly. then, checks to see if the snake collided with itself or the apple. updates the internal representation of the snake, based on its direction. next, the apple and snake are drawn. finally, makes the processor do some busy work, to stop the game from running too quickly. think of it like a sleep command. the game keeps running until the snake collides with the wall or itself.&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;h3&gt;$zero page usage&lt;/h3&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$the zero page of memory is used to store a number of game state variables, as noted in the comment block at the top of the game. everything in , and upwards is a pair of bytes representing a two-byte memory location that will be looked up using indirect addressing. these memory locations will all be between and - the section of memory corresponding to the game console. for example, if and contained the values and , they would be referring to the second pixel of the display ( - remember, the least significant byte comes first in indirect addressing).&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$the first two bytes hold the location of the apple. this is updated every time the snake eats the apple. byte contains the current direction. means up, right, down, and left. the reasoning behind these numbers will become clear later.&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$finally, byte contains the current length of the snake, in terms of bytes in memory (so a length of 4 means 2 pixels).&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;h3&gt;$initialization&lt;/h3&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$the subroutine defers to two subroutines, and . sets the snake direction, length, and then loads the initial memory locations of the snake head and body. the byte pair at contains the screen location of the head, the pair at contains the location of the single body segment, and contains the location of the tail (the tail is the last segment of the body and is drawn in black to keep the snake moving). this happens in the following code:&lt;/p&gt;"></HtmlView>

<HtmlView selectable="true" html="&lt;p&gt;$this loads the value into the memory location , the value into , and into . it then loads the value into , and . this leads to memory like this:&lt;/p&gt;"></HtmlView>

<HtmlView selectable="true" html="&lt;p&gt;$which represents the indirectly-addressed memory locations , and (three pixels in the middle of the display). i&amp;apos;m labouring this point, but it&amp;apos;s important to fully grok how indirect addressing works.&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$the next subroutine, , sets the apple location to a random position on the display. first, it loads a random byte into the accumulator ( is a random number generator in this simulator). this is stored into . next, a different random byte is loaded into the accumulator, which is then -ed with the value . this part requires a bit of a detour.&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$the hex value is represented in binary as . the opcode performs a bitwise and of the argument with the accumulator. for example, if the accumulator contains the binary value , then the result of with will be .&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$the effect of this is to mask out the least significant two bits of the accumulator, setting the others to zero. this converts a number in the range of 0–255 to a number in the range of 0–3.&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$after this, the value is added to the accumulator, to create a final random number in the range 2–5.&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$the result of this subroutine is to load a random byte into , and a random number between 2 and 5 into . because the least significant byte comes first with indirect addressing, this translates into a memory address between and : the exact range used to draw the display.&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;h3&gt;$the game loop&lt;/h3&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$nearly all games have at their heart a game loop. all game loops have the same basic form: accept user input, update the game state, and render the game state. this loop is no different.&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;h4&gt;$reading the input&lt;/h4&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$the first subroutine, , takes the job of accepting user input. the memory location holds the ascii code of the most recent key press in this simulator. the value is loaded into the accumulator, then compared to (the hex code for w), (d), (s) and (a). if any of these comparisons are successful, the program branches to the appropriate section.&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$additional button inputs are also available: button a (enter/return key, ascii code ) and button b (space key, ascii code ). these can be used to add more interaction to your games. for directional controls, both wasd keys and arrow keys can be used interchangeably.&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$each section (, , etc.) first checks to see if the current direction is the opposite of the new direction. this requires another little detour.&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$as stated before, the four directions are represented internally by the numbers 1, 2, 4 and 8. each of these numbers is a power of 2, thus they are represented by a binary number with a single :&lt;/p&gt;"></HtmlView>

<HtmlView selectable="true" html="&lt;p&gt;$the opcode is similar to , but the calculation is only used to set the zero flag - the actual result is discarded. the zero flag is set only if the result of and-ing the accumulator with argument is zero. when we&amp;apos;re looking at powers of two, the zero flag will only be set if the two numbers are not the same. for example, is not zero, but is zero.&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$so, looking at , if the current direction is down (4), the bit test will be zero. means &amp;quot;branch if the zero flag is clear&amp;quot;, so in this case we&amp;apos;ll branch to , which just returns from the subroutine. otherwise, the new direction (1 in this case) is stored in the appropriate memory location.&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;h4&gt;$updating the game state&lt;/h4&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$the next subroutine, , defers to and . just checks to see if the two bytes holding the location of the apple match the two bytes holding the location of the head. if they do, the length is increased and a new apple position is generated.&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$ loops through the snake&amp;apos;s body segments, checking each byte pair against the head pair. if there is a match, then game over.&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$after collision detection, we update the snake&amp;apos;s location. this is done at a high level like so: first, move each byte pair of the body up one position in memory. second, update the head according to the current direction. finally, if the head is out of bounds, handle it as a collision. i&amp;apos;ll illustrate this with some ascii art. each pair of brackets contains an x,y coordinate rather than a pair of bytes for simplicity.&lt;/p&gt;"></HtmlView>

<HtmlView selectable="true" html="&lt;p&gt;$at a low level, this subroutine is slightly more complex. first, the length is loaded into the register, which is then decremented. the snippet below shows the starting memory for the snake.&lt;/p&gt;"></HtmlView>

<HtmlView selectable="true" html="&lt;p&gt;$the length is initialized to , so starts off as . loads the value of into , then stores this value into . is decremented, and we loop. now is , so we load and store it into . this loops while is positive ( means &amp;quot;branch if positive&amp;quot;).&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$once the values have been shifted down the snake, we have to work out what to do with the head. the direction is first loaded into . means &amp;quot;logical shift right&amp;quot;, or &amp;quot;shift all the bits one position to the right&amp;quot;. the least significant bit is shifted into the carry flag, so if the accumulator is , after it is , with the carry flag set.&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$to test whether the direction is , , or , the code continually shifts right until the carry is set. one means &amp;quot;up&amp;quot;, two means &amp;quot;right&amp;quot;, and so on.&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$the next bit updates the head of the snake depending on the direction. this is probably the most complicated part of the code, and it&amp;apos;s all reliant on how memory locations map to the screen, so let&amp;apos;s look at that in more detail.&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$you can think of the screen as four horizontal strips of 32 × 8 pixels. these strips map to , , and . the first rows of pixels are , , , etc.&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$as long as you&amp;apos;re moving within one of these horizontal strips, things are simple. for example, to move right, just increment the least significant byte (e.g. becomes ). to go down, add (e.g. becomes ). left and up are the reverse.&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$going between sections is more complicated, as we have to take into account the most significant byte as well. for example, going down from should lead to . luckily, this is fairly easy to accomplish. adding to results in and sets the carry bit. if the carry bit was set, we know we also need to increment the most significant byte.&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$after a move in each direction, we also need to check to see if the head would become out of bounds. this is handled differently for each direction. for left and right, we can check to see if the head has effectively &amp;quot;wrapped around&amp;quot;. going right from by incrementing the least significant byte would lead to , but this is actually jumping from the last pixel of the first row to the first pixel of the second row. so, every time we move right, we need to check if the new least significant byte is a multiple of . this is done using a bit check against the mask . hopefully the illustration below will show you how masking out the lowest 5 bits reveals whether a number is a multiple of or not.&lt;/p&gt;"></HtmlView>

<HtmlView selectable="true" html="&lt;p&gt;$i won&amp;apos;t explain in depth how each of the directions work, but the above explanation should give you enough to work it out with a bit of study.&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;h4&gt;$rendering the game&lt;/h4&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$because the game state is stored in terms of pixel locations, rendering the game is very straightforward. the first subroutine, , is extremely simple. it sets to zero, loads a random colour into the accumulator, then stores this value into . is where the location of the apple is stored, so dereferences to this memory location. read the &amp;quot;indirect indexed&amp;quot; section in &lt;a href=&quot;#addressing&quot;&gt;addressing modes&lt;/a&gt; for more details.&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$next comes . this is pretty simple too - we first undraw the tail and then draw the head. is set to the length of the snake, so we can index to the right pixel, and we set to zero then perform the write using the indexed indirect addressing mode. then we reload to index to the head, set to one and store it at . stores the two-byte location of the head, so this draws a white pixel at the current head position. as only the head and the tail of the snake move, this is enough to keep the snake moving.&lt;/p&gt;"></HtmlView>
<HtmlView selectable="true" html="&lt;p&gt;$the last subroutine, , is just there because the game would run too fast otherwise. all does is count down from zero until it hits zero again. the first wraps, making .&lt;/p&gt;"></HtmlView></StackLayout>